# -*- coding: utf-8 -*-
"""wenalloys_corrected.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NnF5IW02gpRx0RbiICFqo0tlC8pRwiyw

Corrected WenAlloys Implementation
==================================

WenAlloys featurizer with formula corrections based on Guo (2015).

Fixes:
1. Configuration entropy: added missing negative sign
2. Mixing enthalpy: removed incorrect abs() on individual terms
3. Mean melting temperature: manual calculation for omega
4. Yang omega: corrected to use abs(ΔHmix) in denominator

Reference: https://doi.org/10.1016/j.jallcom.2015.07.209

Dependencies:
    - matminer >= 0.9.0
    - pymatgen >= 2023.0.0
    - numpy >= 1.20.0

Installation:
    pip install matminer pymatgen numpy or local installation

Usage:
    from wenalloys_corrected import CorrectedWenAlloys

    featurizer = CorrectedWenAlloys()
    df_features = featurizer.featurize_dataframe(df, col_id='composition')
"""

import numpy as np
from matminer.featurizers.composition import WenAlloys
from matminer.featurizers.composition.alloy import PropertyStats
from pymatgen.core import Element

class CorrectedWenAlloys(WenAlloys):
    """
    WenAlloys featurizer with corrected formulas according to Guo (2015).

    Inherits from matminer.featurizers.composition.WenAlloys and overrides
    three methods to fix formula errors in the original implementation.
    """

    @staticmethod
    def compute_configuration_entropy(fractions):
        """
        Calculate configuration entropy with correct sign.

        Formula: ΔSmix = -R * Σ(xi * ln(xi))

        Fix: Original matminer implementation was missing the negative sign.
        The entropy of mixing should be negative for spontaneous mixing.

        Args:
            fractions: Atomic fractions of elements

        Returns:
            Configuration entropy in kJ/(mol·K)
        """
        return -np.dot(fractions, np.log(fractions)) * 8.314 / 1000

    def compute_enthalpy(self, elements, fractions):
        """
        Calculate mixing enthalpy preserving sign.

        Formula: ΔHmix = 4 * Σ Σ (xi * xj * ΔHij_mix)

        Fix: Original implementation used abs() on individual mixing enthalpies,
        which incorrectly forced all contributions to be positive. The sign of
        mixing enthalpy is physically meaningful (negative = exothermic).

        Args:
            elements: List of element symbols
            fractions: Atomic fractions of elements

        Returns:
            Mixing enthalpy in kJ/mol (can be positive or negative)
        """
        enthalpy = 0
        for i, e1 in enumerate(elements):
            for j, e2 in enumerate(elements[:i]):
                enthalpy += (
                    fractions[i]
                    * fractions[j]
                    * self.data_source_enthalpy.get_mixing_enthalpy(Element(e1), Element(e2))
                )
        enthalpy *= 4
        return enthalpy

    def featurize(self, comp):
        """
        Extract WenAlloys features with corrected Yang omega calculation.

        Main fix: Yang's omega parameter calculation
        Formula: Ω = Tm * ΔSmix / |ΔHmix|

        Original bug: used ΔHmix directly in denominator without absolute value,
        causing division by negative values and incorrect omega signs.

        Args:
            comp: pymatgen Composition object

        Returns:
            List of 25 WenAlloys features
        """
        # Extract composition data
        composition_dict = comp.fractional_composition.get_el_amt_dict()
        elements = list(composition_dict.keys())
        fractions = list(composition_dict.values())

        # Compute atomic radius and weight statistics
        miracle_radius_stats = self.compute_magpie_summary("MiracleRadius", elements, fractions)
        atomic_weight_stats = self.compute_magpie_summary("AtomicWeight", elements, fractions)

        # Extract element properties from databases
        electronegativity = [self.data_source_miedema.df_dataset.loc[str(e)]["electronegativity"] for e in elements]
        single_VEC = [self.data_source_miedema.df_dataset.loc[str(e)]["valence_electrons"] for e in elements]
        mean_VEC = PropertyStats.mean(single_VEC, fractions)

        cohesive_energy = [self.data_source_cohesive_energy.cohesive_energy_data[str(e)] for e in elements]
        mean_cohesive_energy = PropertyStats.mean(cohesive_energy, fractions)

        shear_modulus = [self.data_source_miedema.df_dataset.loc[str(e)]["shear_modulus"] for e in elements]
        mean_shear_modulus = PropertyStats.mean(shear_modulus, fractions)

        # Calculate unfilled electron counts for s, p, d, f orbitals
        s_unfilled = sum(2 - self.data_source_magpie["NsUnfilled"][e] for e in elements if self.data_source_magpie["NsUnfilled"][e] != 0)
        p_unfilled = sum(6 - self.data_source_magpie["NpUnfilled"][e] for e in elements if self.data_source_magpie["NpUnfilled"][e] != 0)
        d_unfilled = sum(10 - self.data_source_magpie["NdUnfilled"][e] for e in elements if self.data_source_magpie["NdUnfilled"][e] != 0)
        f_unfilled = sum(14 - self.data_source_magpie["NfUnfilled"][e] for e in elements if self.data_source_magpie["NfUnfilled"][e] != 0)
        interant_electrons = s_unfilled + p_unfilled + d_unfilled + f_unfilled

        # Compute weight and atomic fractions
        weight_fraction = self.compute_weight_fraction(elements, comp)
        atomic_fraction = self.compute_atomic_fraction(elements, comp)

        # Yang solid solution parameters
        yang_delta = self.yss.compute_delta(comp)

        # Atomic packing efficiency
        from matminer.featurizers.composition.packing import AtomicPackingEfficiency
        ape = AtomicPackingEfficiency(impute_nan=self.impute_nan).compute_simultaneous_packing_efficiency(comp)[0]

        # Local atomic environment mismatch parameters
        radii_local_mismatch = self.compute_local_mismatch(miracle_radius_stats["array"], fractions)
        radii_gamma = self.compute_gamma_radii(miracle_radius_stats)

        # CORRECTED: Use fixed methods for entropy and enthalpy
        S_config = self.compute_configuration_entropy(fractions)  # Now includes negative sign
        H_mixing = self.compute_enthalpy(elements, fractions)     # Now preserves sign

        # CORRECTED: Manual calculation of mean melting temperature
        # Required because original implementation did not expose Tm for corrected omega formula
        melting_temps = [self.data_source_magpie["MeltingT"][e] for e in elements]
        Tm = PropertyStats.mean(melting_temps, fractions)

        # CORRECTED: Yang omega with absolute value of enthalpy in denominator
        # Formula: Ω = Tm * ΔSmix / |ΔHmix| (Guo 2015, Eq. 4)
        # Prevents division by zero and ensures physically meaningful positive values
        H_mixing_abs = max(1e-6, abs(H_mixing))
        yang_omega_corrected = (Tm * S_config) / H_mixing_abs

        # Additional derived features
        atomic_weight_mean = atomic_weight_stats["mean"]
        wt = comp.weight
        lambda_entropy = self.compute_lambda(yang_delta, S_config)
        X_delta = self.compute_delta(electronegativity, fractions)
        X_local_mismatch = self.compute_local_mismatch(electronegativity, fractions)

        # Shear modulus related features
        shear_modulus_delta = self.compute_delta(shear_modulus, fractions)
        shear_modulus_local_mismatch = self.compute_local_mismatch(shear_modulus, fractions)
        shear_modulus_strength_model = self.compute_strength_local_mismatch_shear(
            shear_modulus=shear_modulus, mean_shear_modulus=mean_shear_modulus, fractions=fractions
        )

        # Return features in original WenAlloys order
        return [
            weight_fraction,
            atomic_fraction,
            yang_delta,
            yang_omega_corrected,  # Corrected feature
            ape,
            radii_local_mismatch,
            radii_gamma,
            S_config,              # Corrected feature
            atomic_weight_mean,
            wt,
            lambda_entropy,
            X_delta,
            X_local_mismatch,
            mean_VEC,
            H_mixing,              # Corrected feature
            mean_cohesive_energy,
            interant_electrons,
            s_unfilled,
            p_unfilled,
            d_unfilled,
            f_unfilled,
            mean_shear_modulus,
            shear_modulus_delta,
            shear_modulus_local_mismatch,
            shear_modulus_strength_model,
        ]